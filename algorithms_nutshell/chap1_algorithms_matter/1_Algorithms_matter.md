# 1 算法很重要

算法真的很重要在哪些情况下使用哪种算法会给你编写的软件的性能带来巨大的差异。

## 1.1 理解问题

理解问题最好从大局观开始：理解问题，找出潜在原因，然后深入挖掘细节。如果你觉得你知道原因，然后决定解决这个问题，那么你可能出错，或你也许不会发现其他更好的答案。

Graham的目的是希望能够知道一个程序是否存在内存泄露。这个问题的最好方法是记录所有被程序分配的内存，不管这些内存是否在程序终止前被释放掉了，同时也记录用户的程序在哪儿请求内存分配。

## 1.2 如果需要，尽可能用实践检验

在继续深入之前，Graham写了一些小程序，通过调用这个库来检查这些程序是如何运行的。第一个测试程序A，代码如下：

```c
int main(int argc, char **argv) {
    int i = 0;
    for(i = 0; i < 1000000; i++) {
        malloc(32);
    }
    exit(0);
}
```

上面的程序运行结束的时候，记录显示有32MB的内存泄漏。如果程序中所有分配的内存都被释放了会出现什么情况呢？做一点小修改就是程序B，代码如下：

```c
int main(int argc, char **argv) {
    int i = 0;
    for(i = 0; i < 1000000; i++) {
        void *x = malloc(32);
        free(x);
    }
    exit(0);
}
```

编译并运行程序B，在几秒内就运行结束了。Graham确信这个问题和程序结束的时候没有释放内存大小相关。但他不知道问题处在哪里。他搜寻了整个代码，花费了数个小时却也找不出问题在哪儿。Gary并不想Graham那样确信问题是与内存泄漏的数目有关。他建议做更多的实验，并对程序做了另一次的修改，将所有的内存释放操作集中到程序的最后，程序C代码如下：

```c
int main(int argc, char **argv) {
    int i = 0;
    void *addrs[1000000];
    for (i = 0; i < 1000000; i++) {
        free(addrs[i]);
    }
    exit(0);
}
```

这个程序就像第一个程序那样运行缓慢。这个例子证明了性能问题并不是由内存泄漏的数量导致的。这个程序让Gary明白了问题原因的真正所在。并不是程序结尾的内存分配次数导致的性能问题，而是任意时刻没有被释放的内存的最大数量严重影响了整个程序的性能。